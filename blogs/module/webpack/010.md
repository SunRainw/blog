---
title: Webpack 的DLL和TreeSharking
date: 2021-08-10
tags:
- webpack
  categories:
- 前端工程化
  sidebar: auto
---

## DLL

### 认识 DLL 库

- DLL 全称是动态链接库(Dynamic Link Library)，是为了软件在 Windows 中实现共享函数库的一种实现方式
- webpack 中也有内置 DLL 的功能，它指的是我们可以将可以共享，并且不经常改变的代码，抽取成一个共享的库
- 这个库在之后编译的过程中，会被引入到其它的项目的代码中

DLL 库的使用分为两步：

- 第一步：打包一个 DLL 库
- 第二步：项目中引入 DLL 库

> 注意：在升级到 webpack4 之后，React 和 Vue 脚手架都移除了 DLL 库，尤大认为 webpack4 已经能够提供很好的性能，不需要去专门维护一个 DLL 库了

### 打包一个 DLL 库

创建一个新的项目，例如：我们打包一个带有`react`和`react-dom`的 DLL

webpack 帮助我们内置了一个 DllPlugin 可以帮助我们打包一个 DLL 的库文件

```js
const path = require("path");
const webpack = require("webpack");

module.exports = {
  entry: {
    react: ["react", "react-dom"],
  },
  output: {
    path: path.resolve(__dirname, "./dll"),
    filename: "dll_[name].js",
    library: "dll_[name]",
  },
  plugins: [
    new webpack.DllPlugin({
      name: "dll_[name]",
      path: path.resolve(__dirname, "./dll/[name].manifest.json"), // 需要生成一个manifest文件，用来对应查找dll
    }),
  ],
};
```

yarn build 以后就会生成一个 dll 文件夹，我们将打包后的 dll 文件运用到其他项目

### 使用打包的 DLL 库

如果我们在代码中使用到了 react 和 react-dom，我们有配置 splitChunks 的情况下，他们会进行分包，打包到一个独立的 chunk 中，但是我们有了 dll_react，就不再需要单独打包它们，可以直接取引用 dll_react

具体步骤如下：

1. 通过 DllReferencePlugin 插件告知要使用的 DLL 库
2. 通过 AddAssetHtmlPlugin 插件，将我们打包的 DLL 库引入到 Html 模块中

```js
module.exports = {
  plugins: [
    new webpack.DllReferencePlugin({
      context: resolveApp("./"), // 告知在哪里查找dll
      manifest: resolveApp("./dll/react.manifest.json"), // 告知manifest的位置
    }),
    new AddAssetHtmlWebpackPlugin({
      // 该插件自动在html中注入dll_react引用，并在build中添加dll_react.js文件
      outputPath: "./auto",
      filepath: resolveApp("./dll/dll_react.js"),
    }),
  ],
};
```

## Terser

### Terser 介绍和安装

#### 介绍

- `Terser`是一个 JavaScript 的解释(Parser)、Mangler(绞肉机)/Compressor(压缩机)的工具集
- 早期我们会使用`uglify-js`来压缩、丑化我们的 JS 代码，但是目前已经不再维护，并且不支持 ES6+的语法
- `Terser`是从`uglify-es`fork 过来的，并且保留它原来的大部分 API 以及适配`uglify-es`和`uglify-js@3`等
- 也就是说，`Terser`可以帮助我们压缩、丑化我们的代码，让我们的 bundle 变得更小

#### 安装

因为`Terser`是一个独立的工具，所以它可以单独安装

```bash
# 全局安装
yarn global add terser
# npm install terser -g

# 局部安装
yarn add terser
# npm install terser
```

### 命令行使用 Terser

```bash
terser [input files] [options]
# 举例
# terser 输入文件 -o 输出文件名 -c(compress，后面可以配置参数，如：arrows=true,arguments=true) -m(mangle，同-c)
# 不传则使用默认配置，如果不配-c -m则只会压缩空格和回车
terser js/file1.js -o foo.min.js -c -m
terser js/file1.js -o foo.min.js -c arrows=true,arguments=true -m keep_classnames=true
```

关于 Terser 的详细配置可以查看文档[compress option](https://github.com/terser/terser#compress-options)和[mangle option](https://github.com/terser/terser#mangle-options)

### Compress 和 Mangle 的部分 options

#### Compress option

- arrows：class 或者 object 中的函数，转换成箭头函数
- arguments：将函数中使用 arguments[index]装成对应的形参名称
- dead_code：移除不可达的代码（tree shaking）
- 其他属性可以查看文档

#### Mangle option

- toplevel：默认值是 false，顶层作用域中的变量名称，进行丑化(转换)
- keep_classnames：默认值是 false，是否保持依赖的类名称
- keep_fnames：默认值是 false，是否保持原来的函数名称
- 其他属性可以查看文档

```bash
npx terser ./src/abc.js -o abc.min.js -c arrows,arguments=true,dead_code -m toplevel=true,keep_classnames=true,keep_fnames=true
```

### Terser 在 webpack 中配置

真实开发中，我们不需要手动的通过 terser 来处理我们的代码，我们可以直接通过 webpack 处理

- 在 webpack 中有一个 minimizer 属性，在 production 模式下，默认就是使用`TerserPlugin`来处理我们的代码(当然还有其他的工具)
- 如果我们对默认的配置不满意，也可以自己来创建 TerserPlugin 的实例，并且覆盖相关的配置

具体操作如下

- 首先，我们需要打开 minimize，让其对我们的代码进行压缩（默认 production 模式下已经打开了）
- 其次，我们可以在 minimizer 创建一个 TerserPlugin：
  - extractComments：默认值为 true，表示会将注释抽取到一个单独的文件中
    - 在开发中，我们不希望保留这个注释时，可以设置为 false
  - parallel：使用多进程并发运行提高构建速度，默认值是 true，并发运行的默认数量：os.cpus().length - 1（就是，cpus 的线程数-1）
    - 我们也可以设置自己的格式，但是使用默认值即可
  - terserOptions：设置我们的 terser 相关的配置
    - compress：设置压缩相关的选项
    - mangle：设置丑化相关的详细，可以直接设置为 true
    - toplevel：底层变量是否进行转换
    - keep_classnames：保留类的名称
    - keep_fnames:保留函数的名称
    - 其他相关参数可以查看上面的文档

```js
const TerserPlugin = require("terser-webpack-plugin");
module.exports = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        parallel: true,
        extractComments: false,
        terserOptions: {
          compress: {
            arguments: false,
            dead_code: true,
          },
          mangle: true,
          toplevel: true,
          keep_classnames: true,
          keep_fnames: true,
        },
      }),
    ],
  },
};
```

## CSS 的压缩

另一个代码的压缩是 css

- css 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等
- css 的压缩我们可以使用另外一个插件：`css-minimizer-webpack-plugin`
- `css-minimizer-webpack-plugin`是使用 cssnano 工具来优化、压缩 CSS(也可以单独使用)

安装`css-minimizer-webpack-plugin`

```bash
yarn add css-minimizer-webpack-plugin -D
# npm install css-minimizer-webpack-plugin -D
```

在 optimization.minimizer 中配置

```js
module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({}),
      new CssMinimizerPlugin({
        parallel: true,
      }),
    ],
  },
};
```

## Scope Hoisting

Scope Hoisting 从 webpack3开始增加的一个新功能，功能是对作用域进行提升，并且让webpack打包后的代码更小、运行更快

默认情况下webpack打包会有很多的函数作用域，包括一些（比如最外层的）IIFE
- 无论是从最开始的代码运行，还是加载一个模块，都需要执行一系列的函数
- Scope Hoisting可以将函数合并到一个模块中来运行

使用Scope Hoisting非常的简单，webpack已经内置了对应的模块
- 在production模式下，默认这个模块就会启用
- 在development模式下，我们需要自己来打开该模块

```js
module.exports = {
  plugins: [
    new webpack.optimize.ModuleConcatenationPlugin()
  ]
}
```