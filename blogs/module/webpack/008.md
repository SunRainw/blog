---
title: Webpack的DevServer和HMR
date: 2021-07-29
tags:
  - webpack
categories:
  - 前端工程化
sidebar: auto
---

## 本地服务搭建

### 为什么要搭建本地服务器

目前我们开发的代码，为了运行需要两个操作：

- npm run build，编译相关的代码;
- 通过 live server 或者直接通过浏览器，打开 index.html 代码，查看效果;

但是这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成编译和展示;
为了完成自动编译，webpack 提供了几种可选的方式:

- webpack watch mode;
- webpack-dev-server;
- webpack-dev-middleware

### Webpack watch

webpack 给我们提供了 watch 模式：

- 在该模式下，webpack 依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译
- 我们不需要再手动去`yarn build`

开启 watch 的方式有两种：

- 在导出的配置中，添加 watch: true;

```js
module.exports = {
  watch: true,
};
```

- 在启动 webpack 的命令中，添加 --watch 的标识;

```json
{
  "script": {
    "watch": "webpack --watch"
  }
}
```

但是这种方式效率不高：

- 对所有的源代码都重新进行编译
- 编译成功后，都会生成新的文件（文件操作 file system）
- live-server 属于 VSCode 插件（vim/webStorm） -> 不属于 webpack 给我们的解决方案
- live-serve 每次都会重新刷新整个页面

### webpack-dev-server

上面的方式可以监听到文件的变化，但是事实上它本事是没有自动刷新浏览器的功能的，当然我们目前是可以使用VSCode中的`live-server`来完成，但是我们不希望这样，那么我们就可以使用`webpack-dev-server`

安装webpack-dev-server
```bash
yarn add webpack-dev-server -D
# or npm install webpack-dev-server -D
```

添加一个新的scripts脚本

```json
{
    "scripts": {
        "serve": "webpack serve"
    }
}
```
我们直接运行`yarn serve`就可以开启一个服务了

`webpack-dev-server`在编译之后不会写入到任何输出文件。而是将bundle文件保留在内存中
- 事实上`webpack-dev-server`使用了一个库叫memfs（以前使用的是memory-fs，后来废弃了）

### webpack-dev-middleware

默认情况下，webpack-dev-server已经帮助我们做好了一切

- 比如通过express启动一个服务，比如HMR（热模块替换）
- 如果我们想要有更好的自由度，可以使用`webpack-dev-middleware`

- `webpack-dev-middleware`是一个封装器(wrapper)，它可以把webpack处理过的文件发送到一个server
- `webpack-dev-server`在内部使用率它，然后它也可以作为一个单独的package来使用，以便根据需求进行更多自定义设置

#### 使用webpack-dev-middleware

安装express和webpack-dev-middleware
```bash
yarn add express webpack-dev-middleware -D
# or npm install express webpack-dev-middleware -D
```

在根目录添加一个serve.js
```js
const express = require("express")
const webpackDevMiddleware = require("webpack-dev-middleware")
const webpack = require("webpack")

const app = express()

// 加载配置信息
const config = require("./webpack.config")

// 将配置信息传递给webpack进行编译
const compiler = webpack(config)

// 将编译后的结果传递给webpackDevMiddleware，之后的请求webpackDevMiddleware()返回的中间件处理
app.use(webpackDevMiddleware(compiler))

app.listen(8888, () => {
    console.log("服务运行在8888端口~")
})
```

然后使用node运行serve.js，就相当于开启了一个类似于上面的serve服务了


## HMR

### 认识模块热替换（HMR）

- HMR的全称是Hot Module Replacement，翻译为模块热替换
- 模块热替换是指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面

HMR通过如下方式来提高开发速度：

- 不重新加载整个页面，这样可以保留某些应用程序的状态不丢失
- 只更新需要变化的内容，节省开发的时间
- 修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的devtools中直接修改样式

使用HMR
- 默认情况下，`webpack-dev-server`已经支持HMR，我们只需要开启即可
- 在不开启HMR的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading

### 开启HMR

修改webpack的配置
```js
module.exports = {
    hot: true
}
```

浏览器可以看到如下效果
![HMR效果](../../images/module/webpack-008-1.png)

但是会发现，当我们修改了某一个模块的代码，依然是刷新的整个页面，这是因为我们需要去指定哪些模块发生更新时，进行HMR

```js
if (module.hot) {
    module.hot.accept("./util.js", () => {
        console.log("util更新了")
    })
}
```