---
title: Webpack配置和Css处理
date: 2021-07-16
tags:
  - webpack
categories:
  - 前端工程化
sidebar: auto
---

## 基本配置

### 指定入口和出口

webpack 默认查找的入口文件是 index.js，在 webpack 中如果找不到入口文件就会报错，我们就可以自己指定入口

指定入口的方式有很多种，

1. 可以直接在项目运行的根目录使用命令行指定入口

```bash
# 指定入口（entry）文件为main.js，出口（output-path）为
npx webpack --entry ./src/main.js -output-path ./build
```

弊端：每次使用命令行都需要输入很长的字符串，而且容易输错

2. 在 scripts 的 build 的命令中添加指定选项，关于配置选项可以在[webpack 配置](https://webpack.docschina.org/api/cli/)中查到

```json
{
  "scripts": {
    "build": "webpack --entry ./src/main.js -output-path ./build"
  }
}
```

弊端：这样指定比较麻烦，配置多了就很长，可阅读性很差

3. 在当前目录下创建一个 webpack.config.js 文件，在该文件进行配置

```javaScript
const path = require("path")

// webpack是使用CommonJS的方式导入的，所以此处需要使用CommonJS的方式导出
module.exports = {
    entry: "./src/main.js", // 指定入口
    output: { // output一般是对象
        filename: "bundle.js", // 打包后文件的名字
        path: path.resolve(__dirname, "./build"), // 指定输入的路径，只能使用绝对路径，dirname可以获取当前目录的绝对路径,resolve可以用于拼接路径
    }
}
```

### 手动指定配置文件

当我们执行`yarn build`时，就会执行 webpack，在执行 webpack 时就会查找当前运行目录下有无**webpack.config.js**文件，有就会根据该文件去编译打包，如果没有就会自己将 src 的 index.js 作为入口编译打包。

如果我们将**webpack.config.js**的文件名修改为**wk.config.js**，我们就可以在`scripts`中添加配置，指定配置文件的路径

```json
{
  "scripts": {
    "build": "webpack --config ./wk.config.js" // 在当前文件夹下的话./可以省略
  }
}
```

### webpack 依赖关系图

webpack 在对项目进行打包时：

- 会根据命令或者配置文件找到入口文件
- 从入口开始，会生成一个**依赖关系图**, 这个**依赖关系图**会包含应用程序中所需要的所有模块(例如：js 文件，css 文件，图片，字体等)
- 然后遍历图结构，打包一个个模块(根据文件的不同使用不同的 loader 来解析)

如果有一个文件没有在**依赖关系图**中(即没有跟入口文件及其关联文件**关联**)，就不会被打包
![webpack依赖关系图](../../images/module/webpack-002-01.png)

还有一个问题是，例如：一个函数如果没有被引用到，webpack 默认还是会打包进去，我们就需要`tree-shaking`来处理(后续)

## Loader

- loader 可以用于对**模块的源代码**进行转换

### 编写案例

通过 js 创建一个元素，并且给它设置一些样式，然后再入口文件引入

```javaScript
// src/component.js
import "../css/index.css"

function component() {
    const element = document.createElement("div")

    element.innerHTML = ["hello", "Webpack"].join(" ")
    element.className = "content"

    return element
}

document.body.appendChild(component())
```

```css
.content {
  color: red;
}
```

此时我们执行`yarn build`，会发现报错（需要一个 loader 来解析）

我们可以将 css 文件看成一个**模块**，我们是用过`import`来加载这个模块的，在加载这个模块时，`webpack`其实不知道如何对其进行加载，我们必须制定对应的 loader 来完成这个功能

### css-loader 使用

对于加载 css 文件来说，我们需要一个读取 css 文件的 loader，常用的就是 css-loader

#### 安装 css-loader

```bash
# 安装css-loader
yarn add css-loader --dev
# or npm install css-loader -D
```

#### css-loader 的使用方案

css-loader 的使用方案有 3 种：

1. 内联方式：这种方式使用较少，因为不方便管理
   - 在引入的样式前面加上使用的 loader，并使用`!`分割

```javaScript
import "css-loader!../css/style.css"
```

2. CLI 方式：在 webpack5 的文档中已经没有了`--module-bind`，实际应用中也比较少，因为比方便管理
3. loader 配置方式

在 webpack.config.js 中的 module.rules 中对 loader 进行配置

module.rules 的配置如下：
- rules 是一个数组：[rule]
- 数组中存放的是一个个 rule，rule 是一个对象，对象中可以设置多个属性
    + test属性：用于对resource(资源)进行匹配，通常会设置成正则表达式
    + use属性：对应的值是一个数组：[UseEntry]， UseEntry是一个对象，可以通过对象的属性来设置一些其他属性
        * loader：必须有，对应的值是一个字符串
        * options：可选的属性，值是一个字符串或者对象，值会被传入到loader中
        * query：目前已经使用options来替代
    > 传递字符串(如:use: [ 'style-loader' ])是 loader 属性的简写方式(如:use: [ { loader: 'style-loader'} ])
    + loader属性：rule.use: [{loader}]的简写

```javaScript
// loader配置的代码
module.exports = {
    ...,
    module: {
        rules: [
            {
                test: /\.css$/, // 用于匹配资源，使用正则表达式匹配
                // loader: "css-loader" // 方式1
                // use: ["css-loader"] // 方式2
                use: [
                    { loader: "css-loader" } // 方式3
                ],
                
            }
        ]
    }
}
```
