---
title: JS代码优化
date: 2021-06-12
tags:
 - JS性能
categories:
 - JS性能相关
sidebar: auto
---

## 如何精准测试JavaScript性能

- 本质上就是采集大量的执行样本进行数学统计和分析
- 作为编码人员无法过多关注数学统计和分析，就使用Benchmark.js的[网站](https://jsperf.com)来完成

### Jsperf使用流程(Jsperf已停止维护，可停止JSBench)

- 使用github账号登录
- 填写个人信息(非必填)
- 填写详细的测试用例信息(title, slug(唯一，会生成空间用来访问测试用例))
- 填写准备代码(DOM操作时经常使用的)
- 填写必要的setup(前置操作，如：打开手机)和teardown(销毁操作，如：释放数据)代码
- 填写测试代码片段

## 慎用全局变量

### 为什么要慎用

- 全局变量定义在全局执行上下文，是所有作用域的顶端
- 全局执行上下文一直存在于上下文执行栈，直到程序退出
    + 这对于GC工作来说也是不利的，因为只要GC发现对象还处于引用状态就不会回收，造成内存的浪费
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

> 全局和局部变量的使用示例

```javaScript
// 全局
let i, str = ""
for (i = 0; i < 1000; i++) {
    str += i
}

// 局部

for(let i = 0; i < 1000; i++) {
    let str = ""
    str += i
}
```

![性能比较](../images/performance/006-01.jpeg)

图1 性能比较
:::tip
可以看到局部变量的效率远高于全局变量，所以要慎用全局变量
:::

## 缓存全局变量

将使用中无法避免的全局变量缓存到局部

```javaScript
<body>
    <input type="button" value="btn" id="btn1">
    <input type="button" value="btn" id="btn2">
    <input type="button" value="btn" id="btn3">
    <p>111</p>
    <input type="button" value="btn" id="btn4">
    <input type="button" value="btn" id="btn5">
    <input type="button" value="btn" id="btn6">
    <p>222</p>
    <input type="button" value="btn" id="btn7">
    <input type="button" value="btn" id="btn8">
    <input type="button" value="btn" id="btn9">
    <p>333</p>
    <script>
        function opt1() {
            let oBtn1 = document.getElementById("btn1")
            let oBtn3 = document.getElementById("btn3")
            let oBtn5 = document.getElementById("btn5")
            let oBtn7 = document.getElementById("btn7")
        }
        function opt2() {
            let obj = document
            let oBtn1 = obj.getElementById("btn1")
            let oBtn3 = obj.getElementById("btn3")
            let oBtn5 = obj.getElementById("btn5")
            let oBtn7 = obj.getElementById("btn7")
        }
    </script>
</body>
```