---
title: JS代码优化
date: 2021-06-12
tags:
 - JS性能
categories:
 - JS性能相关
sidebar: auto
---

## 如何精准测试JavaScript性能

- 本质上就是采集大量的执行样本进行数学统计和分析
- 作为编码人员无法过多关注数学统计和分析，就使用Benchmark.js的[网站](https://jsperf.com)来完成

### Jsperf使用流程(Jsperf已停止维护，可停止JSBench)

- 使用github账号登录
- 填写个人信息(非必填)
- 填写详细的测试用例信息(title, slug(唯一，会生成空间用来访问测试用例))
- 填写准备代码(DOM操作时经常使用的)
- 填写必要的setup(前置操作，如：打开手机)和teardown(销毁操作，如：释放数据)代码
- 填写测试代码片段

## 慎用全局变量

### 为什么要慎用

- 全局变量定义在全局执行上下文，是所有作用域的顶端
- 全局执行上下文一直存在于上下文执行栈，直到程序退出
    + 这对于GC工作来说也是不利的，因为只要GC发现对象还处于引用状态就不会回收，造成内存的浪费
- 如果某个局部作用域出现了同名变量则会遮蔽或污染全局

> 全局和局部变量的使用示例

```javaScript
// 全局
let i, str = ""
for (i = 0; i < 1000; i++) {
    str += i
}

// 局部

for(let i = 0; i < 1000; i++) {
    let str = ""
    str += i
}
```

![性能比较](../images/performance/006-01.jpeg)

图1 性能比较
:::tip
可以看到局部变量的效率远高于全局变量，所以要慎用全局变量
:::

## 缓存全局变量

将使用中无法避免的全局变量缓存到局部

```javaScript
<body>
    <input type="button" value="btn" id="btn1">
    <input type="button" value="btn" id="btn2">
    <input type="button" value="btn" id="btn3">
    <p>111</p>
    <input type="button" value="btn" id="btn4">
    <input type="button" value="btn" id="btn5">
    <input type="button" value="btn" id="btn6">
    <p>222</p>
    <input type="button" value="btn" id="btn7">
    <input type="button" value="btn" id="btn8">
    <input type="button" value="btn" id="btn9">
    <p>333</p>
    <script>
        function opt1() {
            let oBtn1 = document.getElementById("btn1")
            let oBtn3 = document.getElementById("btn3")
            let oBtn5 = document.getElementById("btn5")
            let oBtn7 = document.getElementById("btn7")
        }
        function opt2() {
            let obj = document
            let oBtn1 = obj.getElementById("btn1")
            let oBtn3 = obj.getElementById("btn3")
            let oBtn5 = obj.getElementById("btn5")
            let oBtn7 = obj.getElementById("btn7")
        }
    </script>
</body>
```

## 节点添加优化

节点的添加操作必然会有回流和重绘

```html
<body>
    <script>
        for (let i = 0; i < 10; i++) {
            let op= = document.createElement("p")
            op.innerHTML = i
            document.body.appendChild(op)
        }

        // 采用文档碎片方式创建虚拟节点
        const fragEle = document.createDocumentFragement()
        for (let i = 0; i < 10; i++) {
            let op= = document.createElement("p")
            op.innerHTML = i
            fragEle.appendChild(op)
        }
        document.body.appendChild(fragEle)
    </script>
</body>
```
分析可见，采用文档碎片优化节点的方式会比直接create和append快一点（差距不大）

## 克隆优化节点操作

```html
<body>
    <p id="box1">old</p>
    <script>
        // 新增
        for (let i = 0; i < 3; i++) {
            let op = document.createElement("p")
            op.innerHTML = i
            document.body.appendChild(op)
        }
        // 克隆
        let oldP = document.getElementById("box1")
        for (let i =0; i < 3; i++) {
            let newP = oldP.cloneNode(false)
            newP.innerHTML = i
            document.body.appendChild(newP)

        }
    </script>
</body>
```
将代码分析后可以看出，克隆节点要比新增节点效率高一点点（其实是差不多的）

## 直接量替换Object

```javaScript
const a = [1, 2, 3]
const a1 = new Array(3)
a1[0] = 1
a1[1] = 2
a1[2] = 3
```
将代码分析后可以看出，直接使用字面量创建数组或对象更快，差异很明显

